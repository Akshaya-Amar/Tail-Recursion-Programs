ğ—¡ğ—¼ğ—»-ğ˜ğ—®ğ—¶ğ—¹ ğ—¿ğ—²ğ—°ğ˜‚ğ—¿ğ˜€ğ—¶ğ—¼ğ—» ğ˜ğ—¼ ğ—§ğ—®ğ—¶ğ—¹ ğ—¿ğ—²ğ—°ğ˜‚ğ—¿ğ˜€ğ—¶ğ—¼ğ—»

Slower execution to faster execution

O(n) space to O(1) space



ğ—§ğ—®ğ—¶ğ—¹ ğ—¿ğ—²ğ—°ğ˜‚ğ—¿ğ˜€ğ—¶ğ—¼ğ—»

A recursive call is said to be tail recursive if it is the last statement to be executed inside a function and that call is not a part of expression.

eg:

int fact(int num, int res){

if(num == 1){

return res;

}

return fact(num - 1, num * res);  // tail recursive call

}



In tail recursive function, no pending operations are left after making  a recursive call. So, no need to store the record of the previous state i.e. no need to push a new activation record for each recursive call in the stack.



ğ—¡ğ—¼ğ—»-ğ˜ğ—®ğ—¶ğ—¹ ğ—¿ğ—²ğ—°ğ˜‚ğ—¿ğ˜€ğ—¶ğ—¼ğ—»

int fact(int num) {

if(num == 1) {

return 1;

}

return num * fact(num - 1); // not a tail recursive call

}



Non-Tail recursive functions have to finish the pending work after the recursive call finishes, so activation record for each recursive call has to be maintained in the stack.



ğ—¥ğ—²ğ—°ğ˜‚ğ—¿ğ˜€ğ—¶ğ—¼ğ—» ğ—¶ğ˜€ ğ˜€ğ—¹ğ—¼ğ˜„ because of the ğ˜ğ—¶ğ—ºğ—² ğ˜€ğ—½ğ—²ğ—»ğ˜ ğ—¶ğ—» ğ—½ğ˜‚ğ˜€ğ—µğ—¶ğ—»ğ—´ ğ—®ğ—»ğ—± ğ—½ğ—¼ğ—½ğ—½ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¿ğ—²ğ—°ğ—¼ğ—¿ğ—±ğ˜€ on and from the stack for each recursive call and ğ—²ğ˜…ğ—½ğ—²ğ—»ğ˜€ğ—¶ğ˜ƒğ—² ğ—¶ğ—» ğ˜ğ—²ğ—¿ğ—ºğ˜€ ğ—¼ğ—³ ğ—ºğ—²ğ—ºğ—¼ğ—¿ğ˜† as well because ğ—¶ğ˜ ğ—¿ğ—²ğ—¾ğ˜‚ğ—¶ğ—¿ğ—²ğ˜€ ğ˜€ğ—½ğ—®ğ—°ğ—² ğ—¶ğ—» ğ˜ğ—µğ—² ğ˜€ğ˜ğ—®ğ—°ğ—¸ ğ˜ğ—¼ ğ˜€ğ˜ğ—¼ğ—¿ğ—² ğ˜ğ—µğ—² ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¿ğ—²ğ—°ğ—¼ğ—¿ğ—±ğ˜€ for each recursive call and ğ—¶ğ—³ ğ˜ğ—µğ—² ğ˜€ğ˜ğ—®ğ—°ğ—¸ ğ—¶ğ˜€ ğ˜ğ—¼ğ—¼ ğ—±ğ—²ğ—²ğ—½, ğ˜ğ—µğ—²ğ—» ğ˜€ğ˜ğ—®ğ—°ğ—¸ ğ—ºğ—®ğ˜† ğ—¼ğ˜ƒğ—²ğ—¿ğ—³ğ—¹ğ—¼ğ˜„ ğ˜ğ—¼ğ—¼.



This can be improved by making recursive program as tail recursive ğ—®ğ˜€ ğ—¶ğ˜ ğ—±ğ—¼ğ—²ğ˜€ğ—»'ğ˜ ğ—¶ğ—»ğ˜ƒğ—¼ğ—¹ğ˜ƒğ—²ğ˜€ ğ˜ğ—µğ—² ğ—½ğ˜‚ğ˜€ğ—µğ—¶ğ—»ğ—´ ğ—®ğ—»ğ—± ğ—½ğ—¼ğ—½ğ—½ğ—¶ğ—»ğ—´ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—»ğ˜€, ğ—¿ğ—®ğ˜ğ—µğ—²ğ—¿ ğ˜ğ—µğ—² ğ—½ğ—¿ğ—²ğ˜ƒğ—¶ğ—¼ğ˜‚ğ˜€ ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¿ğ—²ğ—°ğ—¼ğ—¿ğ—± ğ—´ğ—²ğ˜ğ˜€ ğ—¼ğ˜ƒğ—²ğ—¿ğ˜„ğ—¿ğ—¶ğ˜ğ˜ğ—²ğ—» ğ—¯ğ˜† ğ˜ğ—µğ—² ğ—°ğ˜‚ğ—¿ğ—¿ğ—²ğ—»ğ˜ ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¿ğ—²ğ—°ğ—¼ğ—¿ğ—± when a recursive call occurs, while retaining the original return address. So, at a time we have only one activation record on the stack and that too for the currently executing recursive call. So, it doesn't matter that how deep the recursion is, ğ˜ğ—µğ—² ğ˜€ğ—½ğ—®ğ—°ğ—² ğ—¿ğ—²ğ—¾ğ˜‚ğ—¶ğ—¿ğ—²ğ—ºğ—²ğ—»ğ˜ ğ˜„ğ—¶ğ—¹ğ—¹ ğ—®ğ—¹ğ˜„ğ—®ğ˜†ğ˜€ ğ—¯ğ—² ğ—°ğ—¼ğ—»ğ˜€ğ˜ğ—®ğ—»ğ˜ ğ—®ğ—»ğ—± ğ—¶ğ—ºğ—½ğ—¿ğ—¼ğ˜ƒğ—²ğ˜€ ğ˜ğ—µğ—² ğ—¼ğ˜ƒğ—²ğ—¿ğ—®ğ—¹ğ—¹ ğ—½ğ—²ğ—¿ğ—³ğ—¼ğ—¿ğ—ºğ—®ğ—»ğ—°ğ—² by reducing the time and space/memory requirements.



Tail recursion is a compile level optimisation. Some modern compiler can detect tail recursion and perform the optimisation by converting it to iteration to improve performance.



Java, python don't support tail recursion while C and C++ do.



ğ—¥ğ—²ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—²:

Data Structures through C in Depth by S.K.Srivastava/Deepali Srivastava



Want to know more about recursion, then refer the Slide Deck prepared by Mayank  where ğ—µğ—² ğ—µğ—®ğ˜€ ğ˜‚ğ˜€ğ—²ğ—± ğ—µğ—¶ğ˜€ ğ—°ğ—¿ğ—²ğ—®ğ˜ğ—¶ğ˜ƒğ—¶ğ˜ğ˜† ğ˜ğ—¼ ğ—²ğ˜…ğ—½ğ—¹ğ—®ğ—¶ğ—» ğ—¿ğ—²ğ—°ğ˜‚ğ—¿ğ˜€ğ—¶ğ—¼ğ—» ğ—¶ğ—» ğ˜ğ—µğ—² ğ—°ğ—¼ğ—»ğ˜ƒğ—²ğ—¿ğ˜€ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ˜€ğ˜ğ˜†ğ—¹ğ—² as we normally do in our daily lives.



ğ—™ğ—¼ğ—¿ ğ—§ğ—®ğ—¶ğ—¹ ğ—¿ğ—²ğ—°ğ˜‚ğ—¿ğ˜€ğ—¶ğ˜ƒğ—² ğ—½ğ—¿ğ—¼ğ—´ğ—¿ğ—®ğ—ºğ˜€, ğ—¿ğ—²ğ—³ğ—²ğ—¿ ğ˜ğ—¼ ğ˜ğ—µğ—² ğ—³ğ—¼ğ—¹ğ—¹ğ—¼ğ˜„ğ—¶ğ—»ğ—´ ğ—¹ğ—¶ğ—»ğ—¸.
